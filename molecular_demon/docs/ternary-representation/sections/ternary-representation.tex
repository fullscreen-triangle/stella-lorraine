\section{Ternary Representation}
\label{sec:ternary}

\subsection{Ternary Digits and Strings}

\begin{definition}[Trit]
A \textbf{trit} (ternary digit) is an element of the set $\mathbb{T} = \{0, 1, 2\}$.
\end{definition}

\begin{definition}[Ternary String]
A \textbf{ternary string of length $k$} is an element of $\mathbb{T}^k = \{0, 1, 2\}^k$. We denote such a string as $\mathbf{t} = (t_1, t_2, \ldots, t_k)$ or simply $t_1 t_2 \cdots t_k$.
\end{definition}

\begin{definition}[Infinite Ternary String]
An \textbf{infinite ternary string} is an element of $\mathbb{T}^\infty = \{0, 1, 2\}^{\mathbb{Z}^+}$, denoted $\mathbf{t} = (t_1, t_2, t_3, \ldots)$.
\end{definition}

\subsection{Ternary Numerical Representation}

\begin{definition}[Ternary Expansion]
The \textbf{ternary expansion} of a real number $x \in [0,1]$ is:
\begin{equation}
x = \sum_{i=1}^{\infty} t_i \cdot 3^{-i} = 0.t_1 t_2 t_3 \ldots_3
\end{equation}
where $t_i \in \{0, 1, 2\}$.
\end{definition}

\begin{theorem}[Existence of Ternary Expansion]
Every $x \in [0,1]$ has at least one ternary expansion.
\end{theorem}

\begin{proof}
Construct the expansion iteratively:
\begin{enumerate}
    \item Set $r_0 = x$
    \item For $i \geq 1$: set $t_i = \lfloor 3r_{i-1} \rfloor$ and $r_i = 3r_{i-1} - t_i$
\end{enumerate}

Since $r_0 \in [0,1]$, we have $3r_0 \in [0,3]$, so $t_1 \in \{0, 1, 2\}$ and $r_1 \in [0,1)$. By induction, $t_i \in \{0, 1, 2\}$ and $r_i \in [0,1)$ for all $i \geq 1$.

The expansion satisfies:
\begin{equation}
x = \sum_{i=1}^{n} t_i \cdot 3^{-i} + 3^{-n} r_n
\end{equation}

As $n \to \infty$, $3^{-n} r_n \to 0$ (since $|r_n| \leq 1$), giving the result. \qed
\end{proof}

\begin{theorem}[Uniqueness of Ternary Expansion]
The ternary expansion is unique except for numbers of the form $m/3^n$ which admit two representations (one ending in $\overline{0}$ and one ending in $\overline{2}$).
\end{theorem}

\begin{proof}
Suppose $x = \sum_{i=1}^\infty t_i \cdot 3^{-i} = \sum_{i=1}^\infty t'_i \cdot 3^{-i}$ with $t_j \neq t'_j$ for some minimal $j$.

Then:
\begin{equation}
\sum_{i=j}^\infty (t_i - t'_i) \cdot 3^{-i} = 0
\end{equation}

Without loss of generality, assume $t_j > t'_j$. Then $t_j - t'_j \geq 1$, giving:
\begin{equation}
(t_j - t'_j) \cdot 3^{-j} + \sum_{i=j+1}^\infty (t_i - t'_i) \cdot 3^{-i} = 0
\end{equation}

The sum $\sum_{i=j+1}^\infty (t_i - t'_i) \cdot 3^{-i}$ is bounded by $\pm \sum_{i=j+1}^\infty 2 \cdot 3^{-i} = \pm 3^{-j}$.

For equality, we need $t_j - t'_j = 1$ and $\sum_{i=j+1}^\infty (t_i - t'_i) \cdot 3^{-i} = -3^{-j}$.

This requires $t'_i = 2$ and $t_i = 0$ for all $i > j$, giving the two representations of $m/3^n$. \qed
\end{proof}

\subsection{Information Content}

\begin{definition}[Ternary Information]
The information content of a $k$-trit string is:
\begin{equation}
I_k = k \log_2 3 \approx 1.585k \text{ bits}
\end{equation}
\end{definition}

\begin{proposition}[Ternary Efficiency]
Ternary representation is more efficient than binary:
\begin{equation}
\frac{\text{Information per digit}}{\text{Digit count}} = \log_2 \text{(base)}
\end{equation}
with $\log_2 3 \approx 1.585 > \log_2 2 = 1$.
\end{proposition}

\begin{proof}
A $k$-trit string encodes $3^k$ values. A $k$-bit string encodes $2^k$ values.

For equal information content $N$:
\begin{align}
k_2 &= \log_2 N \text{ bits} \\
k_3 &= \log_3 N = \frac{\log_2 N}{\log_2 3} \approx 0.631 \log_2 N \text{ trits}
\end{align}

Ternary requires only 63.1\% as many digits. \qed
\end{proof}

\begin{remark}
This efficiency advantage, noted by \cite{hayes2001third}, suggests that ternary is closer to the optimal radix $e \approx 2.718$ for representation economy. However, the structural advantages for S-entropy encoding are more significant than this numerical efficiency.
\end{remark}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{figures/figure_6_information_density.png}
  \caption{\textbf{Ternary Representation Achieves 2.85× State Space Density and 1.34× Storage Efficiency Over Binary Through Higher Radix Exponential Growth.}
  \textbf{(Top Left)} Three-dimensional state space comparison between ternary tryte (729 states, blue spheres) and binary byte (256 states, red triangles). Tryte uses 6 trits yielding $3^6 = 729$ unique states, while byte uses 8 bits yielding $2^8 = 256$ states. Yellow annotation box: "Tryte: 2.85× more states than Byte" quantifies advantage ratio $729/256 = 2.85$. Spatial distribution in unit cube $[0,1]^3$ shows blue spheres (ternary) densely filling 3D space with uniform coverage, while red triangles (binary) occupy sparser positions. Axes labeled Dimension 1, Dimension 2, Dimension 3 span 0.0 to 1.0. Legend (bottom left): blue circle "Tryte (729 states)", red triangle "Byte (256 states)". State positions determined by mapping functions: ternary $\vec{s}_3 = f(\text{trit}_0, ..., \text{trit}_5)$ and binary $\vec{s}_2 = g(\text{bit}_0, ..., \text{bit}_7)$. The 2.85× density advantage demonstrates ternary's superior information packing in equivalent dimensional space.
  \textbf{(Top Right)} Logarithmic plot comparing exponential information density growth: binary $2^n$ (red circles) versus ternary $3^n$ (blue squares). Y-axis: Number of States (log scale) from $10^1$ to $10^4$. X-axis: Number of Digits from 2 to 10. Green annotation with arrow at digit count 6: "11.39×" indicates ternary advantage $3^{10}/2^{10} = 59049/1024 \approx 11.39$ at 10 digits. Red line (Binary $2^n$) grows from 4 states (2 digits) to 1024 states (10 digits). Blue line (Ternary $3^n$) grows from 9 states (2 digits) to 59049 states (10 digits). Vertical dashed lines at digit counts 6 (Tryte) and 8 (Byte) mark standard data unit sizes. The exponential divergence follows $(3/2)^n$, demonstrating that ternary advantage grows multiplicatively with digit count, reaching 57.67× at $n=10$.
  \textbf{(Bottom Left)} Relative performance comparison across four key metrics with binary normalized to 1.0 baseline (red dashed line). Four metric categories on X-axis: States/Digit, Search Speed, Hardware Complexity, Information Density. Y-axis: Relative Performance from 0.0 to 3.0. Red bars (Binary): all at 1.00 baseline. Cyan bars (Ternary): \textbf{(1) States/Digit = 3.00}, calculated as $\log_2(3) \approx 1.585$ bits per trit, representing 58.5\% information density increase per digit. \textbf{(2) Search Speed = 1.89}, derived from reduced tree depth $\log_3(N)/\log_2(N) = \log(2)/\log(3) \approx 0.631$, meaning 37\% fewer levels. \textbf{(3) Hardware Complexity = 1.50}, reflecting 50\% increase in circuit complexity for three-level logic gates. \textbf{(4) Information Density = 2.85}, matching state space ratio $3^6/2^8$ for equivalent digit counts. Legend (top right): red "Binary", cyan "Ternary". Ternary bars consistently exceed binary baseline except for hardware complexity, confirming net advantage despite modest circuit overhead.
  \textbf{(Bottom Right)} Storage capacity comparison showing digits required for encoding various data sizes. X-axis: Data Size (states) on log scale: 1, 10, 100, 1000, 10000. Y-axis: Digits Required from 0 to 14. Red bars (Binary bits): 1 state requires 1 bit, 10 states require 4 bits ($\lceil\log_2(10)\rceil = 4$), 100 states require 7 bits, 1000 states require 10 bits, 10000 states require 14 bits. Cyan bars (Ternary trits): 1 state requires 1 trit, 10 states require 3 trits ($\lceil\log_3(10)\rceil = 3$), 100 states require 5 trits, 1000 states require 7 trits, 10000 states require 9 trits. Yellow annotation box: "Average efficiency: Ternary uses 1.34× fewer digits" quantifies storage reduction factor $\log_2(N)/\log_3(N) = \log(3)/\log(2) \approx 1.585/1.0 = 1.585$, or equivalently, ternary uses $1/1.585 \approx 0.631$ times as many digits, representing 36.9\% reduction. Numerical labels on bars show exact digit counts. This demonstrates ternary's practical advantage in memory footprint and addressing space.}
  \label{fig:information_density}
\end{figure}


\subsection{The Tryte: Ternary Byte}

\begin{definition}[Tryte]
A \textbf{tryte} is a ternary string of length 6:
\begin{equation}
\tryte = (t_1, t_2, t_3, t_4, t_5, t_6) \in \mathbb{T}^6
\end{equation}
encoding $3^6 = 729$ distinct values.
\end{definition}

\begin{remark}
The tryte is analogous to the byte (8 bits = 256 values) but encodes nearly three times as many values with only 6 digits. The choice of 6 trits ensures that each S-entropy dimension receives 2 refinements per tryte.
\end{remark}

\begin{proposition}[Tryte Structure]
A tryte encodes position to depth 6 in the $3^k$ hierarchy:
\begin{itemize}
    \item Trits 1, 4: refine $\Sk$ (2 refinements $\to$ resolution $1/9$)
    \item Trits 2, 5: refine $\St$ (2 refinements $\to$ resolution $1/9$)
    \item Trits 3, 6: refine $\Se$ (2 refinements $\to$ resolution $1/9$)
\end{itemize}
\end{proposition}

\begin{definition}[Tryte Sequence]
A sequence of $n$ trytes encodes position to depth $6n$:
\begin{equation}
(\tryte_1, \tryte_2, \ldots, \tryte_n) \in (\mathbb{T}^6)^n \cong \mathbb{T}^{6n}
\end{equation}
with resolution $3^{-2n}$ in each dimension.
\end{definition}

\subsection{Balanced Ternary}

\begin{definition}[Balanced Ternary]
\textbf{Balanced ternary} uses digit set $\{-1, 0, +1\}$ (often written $\{\bar{1}, 0, 1\}$):
\begin{equation}
x = \sum_{i=1}^{\infty} b_i \cdot 3^{-i} \quad \text{where } b_i \in \{-1, 0, +1\}
\end{equation}
\end{definition}

\begin{proposition}[Balanced Ternary Range]
Balanced ternary with $k$ digits represents values in $[-\frac{3^k - 1}{2 \cdot 3^k}, +\frac{3^k - 1}{2 \cdot 3^k}]$.
\end{proposition}

\begin{proof}
Maximum value: $\sum_{i=1}^k 3^{-i} = \frac{1 - 3^{-k}}{1 - 3^{-1}} \cdot 3^{-1} = \frac{3^k - 1}{2 \cdot 3^k}$.

Minimum value: $-\frac{3^k - 1}{2 \cdot 3^k}$ (by symmetry). \qed
\end{proof}

\begin{remark}
Balanced ternary naturally centres around zero and simplifies arithmetic (no separate sign bit needed). However, for S-entropy encoding where coordinates lie in $[0,1]$, unbalanced ternary $\{0, 1, 2\}$ provides a more direct mapping.
\end{remark}

\subsection{Conversion Between Binary and Ternary}

\begin{definition}[Binary-to-Ternary Conversion]
Given a binary string $\mathbf{b} = (b_1, \ldots, b_n) \in \{0,1\}^n$ representing value $v = \sum_{i=1}^n b_i \cdot 2^{n-i}$:

\textbf{Step 1}: Compute $v$ in standard integer arithmetic.

\textbf{Step 2}: Convert to ternary by repeated division:
\begin{align}
v &= 3q_1 + t_k \\
q_1 &= 3q_2 + t_{k-1} \\
&\vdots \\
q_{k-1} &= 3 \cdot 0 + t_1
\end{align}
where $t_i \in \{0, 1, 2\}$ and $k = \lceil \log_3 v \rceil$.
\end{definition}

\begin{proposition}[Conversion Complexity]
Binary-to-ternary conversion requires $O(\log n)$ divisions where $n$ is the value represented.
\end{proposition}

