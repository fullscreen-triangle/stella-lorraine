<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stella-Lorraine Interactive D3 Visualizations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }

        .viz-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .viz-panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .viz-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-align: center;
            color: #ffd700;
        }

        .controls {
            text-align: center;
            margin: 15px 0;
        }

        .control-group {
            display: inline-block;
            margin: 0 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .control-group input, .control-group select {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .control-group input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .svg-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 6px;
            pointer-events: none;
            font-size: 12px;
            border: 1px solid #ffd700;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .axis {
            font-size: 12px;
        }

        .axis text {
            fill: white;
        }

        .axis path,
        .axis line {
            stroke: rgba(255, 255, 255, 0.6);
        }

        .legend {
            font-size: 12px;
        }

        .legend text {
            fill: white;
        }

        .oscillation-path {
            fill: none;
            stroke-width: 2;
        }

        .stella-lorraine {
            stroke: #ff4757;
            stroke-width: 3;
        }

        .comparison-system {
            stroke: #3742fa;
            stroke-width: 2;
            opacity: 0.7;
        }

        .performance-bar {
            transition: all 0.3s ease;
        }

        .performance-bar:hover {
            opacity: 0.8;
            stroke: #ffd700;
            stroke-width: 2;
        }

        .consciousness-node {
            transition: all 0.3s ease;
        }

        .consciousness-node:hover {
            r: 8;
            stroke: #ffd700;
            stroke-width: 3;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .pulsing {
            animation: pulse 2s infinite;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .metrics-text {
            font-size: 14px;
            fill: #ffd700;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Stella-Lorraine Interactive Visualizations</h1>
            <p>Universal Oscillatory Framework • Memorial Consciousness Analysis • Precision Timing</p>
        </div>

        <div class="visualization-grid">
            <!-- Real-time Oscillation Visualization -->
            <div class="viz-panel">
                <div class="viz-title">Multi-Scale Oscillatory Framework</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Animation Speed</label>
                        <input type="range" id="oscillation-speed" min="0.1" max="5" value="1" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Scale Coupling</label>
                        <input type="range" id="coupling-strength" min="0" max="1" value="0.5" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>System</label>
                        <select id="oscillation-system">
                            <option value="stella">Stella-Lorraine</option>
                            <option value="harmonic">Simple Harmonic</option>
                            <option value="damped">Damped Harmonic</option>
                            <option value="coupled">Coupled Oscillators</option>
                        </select>
                    </div>
                </div>
                <div class="svg-container">
                    <svg id="oscillation-viz" width="100%" height="400"></svg>
                </div>
            </div>

            <!-- Performance Comparison Chart -->
            <div class="viz-panel">
                <div class="viz-title">Precision Timing Performance</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Metric</label>
                        <select id="performance-metric">
                            <option value="latency">Mean Latency</option>
                            <option value="precision">Precision (ns)</option>
                            <option value="stability">Stability Score</option>
                            <option value="efficiency">Resource Efficiency</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Scale</label>
                        <select id="performance-scale">
                            <option value="linear">Linear</option>
                            <option value="log">Logarithmic</option>
                        </select>
                    </div>
                </div>
                <div class="svg-container">
                    <svg id="performance-viz" width="100%" height="400"></svg>
                </div>
            </div>

            <!-- Consciousness Targeting Interface -->
            <div class="viz-panel">
                <div class="viz-title">Consciousness Targeting Analysis</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Population Size</label>
                        <input type="range" id="population-size" min="100" max="10000" value="1000" step="100">
                        <span id="population-display">1000</span>
                    </div>
                    <div class="control-group">
                        <label>Free Will Factor</label>
                        <input type="range" id="free-will-factor" min="0" max="1" value="0.5" step="0.05">
                        <span id="freewill-display">0.5</span>
                    </div>
                    <div class="control-group">
                        <label>Nordic Paradox</label>
                        <input type="checkbox" id="nordic-paradox" checked>
                    </div>
                </div>
                <div class="svg-container">
                    <svg id="consciousness-viz" width="100%" height="400"></svg>
                </div>
            </div>

            <!-- Memorial System Navigator -->
            <div class="viz-panel">
                <div class="viz-title">Memorial System Comparison</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Comparison Type</label>
                        <select id="memorial-comparison">
                            <option value="effectiveness">Effectiveness</option>
                            <option value="cost">Cost Analysis</option>
                            <option value="longevity">Temporal Persistence</option>
                            <option value="accessibility">Accessibility</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Show Traditional</label>
                        <input type="checkbox" id="show-traditional" checked>
                    </div>
                </div>
                <div class="svg-container">
                    <svg id="memorial-viz" width="100%" height="400"></svg>
                </div>
            </div>

            <!-- Integrated Dashboard -->
            <div class="viz-panel full-width">
                <div class="viz-title">Stella-Lorraine Comprehensive Dashboard</div>
                <div class="controls">
                    <div class="control-group">
                        <label>Time Range</label>
                        <select id="time-range">
                            <option value="1min">1 Minute</option>
                            <option value="1hour">1 Hour</option>
                            <option value="1day">1 Day</option>
                            <option value="1week">1 Week</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Update Rate</label>
                        <input type="range" id="update-rate" min="100" max="5000" value="1000" step="100">
                        <span id="update-display">1000ms</span>
                    </div>
                    <div class="control-group">
                        <label>Auto-Update</label>
                        <input type="checkbox" id="auto-update" checked>
                    </div>
                </div>
                <div class="svg-container">
                    <svg id="dashboard-viz" width="100%" height="600"></svg>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip div -->
    <div id="tooltip" class="tooltip" style="opacity: 0;"></div>

    <script>
        // Stella-Lorraine D3.js Visualization Suite
        class StellaLorraineVisualizations {
            constructor() {
                this.tooltip = d3.select("#tooltip");
                this.animationSpeed = 1;
                this.isAnimating = true;

                // Sample data - in real implementation, load from JSON files
                this.performanceData = [
                    {name: "time.time()", latency: 0.5, precision: 1000, stability: 0.3, efficiency: 0.6},
                    {name: "time.perf_counter()", latency: 0.2, precision: 1, stability: 0.8, efficiency: 0.7},
                    {name: "Arrow", latency: 1.2, precision: 1000, stability: 0.5, efficiency: 0.4},
                    {name: "Pendulum", latency: 1.5, precision: 1000, stability: 0.5, efficiency: 0.4},
                    {name: "Stella-Lorraine", latency: 0.0001, precision: 0.1, stability: 0.95, efficiency: 0.99}
                ];

                this.memorialData = [
                    {name: "Traditional", effectiveness: 0.3, cost: 1000, longevity: 0.3, accessibility: 0.4},
                    {name: "Digital", effectiveness: 0.6, cost: 100, longevity: 0.6, accessibility: 0.8},
                    {name: "Stella-Lorraine", effectiveness: 0.95, cost: 10, longevity: 0.98, accessibility: 0.99}
                ];

                this.initializeVisualizations();
                this.setupEventListeners();
                this.startAnimations();
            }

            initializeVisualizations() {
                this.initOscillationViz();
                this.initPerformanceViz();
                this.initConsciousnessViz();
                this.initMemorialViz();
                this.initDashboard();
            }

            initOscillationViz() {
                const svg = d3.select("#oscillation-viz");
                const margin = {top: 20, right: 30, bottom: 40, left: 50};
                const width = 550 - margin.left - margin.right;
                const height = 400 - margin.top - margin.bottom;

                svg.selectAll("*").remove();

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // Scales
                const xScale = d3.scaleLinear()
                    .domain([0, 2 * Math.PI])
                    .range([0, width]);

                const yScale = d3.scaleLinear()
                    .domain([-2, 2])
                    .range([height, 0]);

                // Axes
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale).tickFormat(d => `${(d/Math.PI).toFixed(1)}π`));

                g.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(yScale));

                // Line generator
                const line = d3.line()
                    .x(d => xScale(d.x))
                    .y(d => yScale(d.y))
                    .curve(d3.curveCardinal);

                // Initialize paths for different oscillation types
                const pathContainer = g.append("g");

                this.oscillationElements = {
                    svg: g,
                    xScale: xScale,
                    yScale: yScale,
                    line: line,
                    pathContainer: pathContainer
                };

                this.updateOscillationViz();
            }

            updateOscillationViz() {
                const system = d3.select("#oscillation-system").property("value");
                const speed = +d3.select("#oscillation-speed").property("value");
                const coupling = +d3.select("#coupling-strength").property("value");

                const { pathContainer, line, xScale, yScale } = this.oscillationElements;

                // Generate oscillation data based on system type
                const data = this.generateOscillationData(system, coupling);

                // Update paths
                const paths = pathContainer.selectAll(".oscillation-path")
                    .data(data, d => d.id);

                paths.enter()
                    .append("path")
                    .attr("class", d => `oscillation-path ${d.id === 'stella' ? 'stella-lorraine' : 'comparison-system'}`)
                    .merge(paths)
                    .transition()
                    .duration(500)
                    .attr("d", d => line(d.points));

                paths.exit().remove();

                // Update legend
                this.updateOscillationLegend(data);
            }

            generateOscillationData(systemType, coupling) {
                const points = 200;
                const data = [];

                if (systemType === 'stella' || systemType === 'all') {
                    // Stella-Lorraine multi-scale oscillation
                    const stellaPoints = [];
                    for (let i = 0; i < points; i++) {
                        const x = (i / points) * 2 * Math.PI;

                        // Multi-scale nested oscillations
                        const quantum = 0.01 * Math.sin(x * 50 + Date.now() * 0.01);
                        const atomic = 0.05 * Math.sin(x * 20 + Date.now() * 0.005);
                        const molecular = 0.1 * Math.sin(x * 10 + Date.now() * 0.002);
                        const macro = 0.5 * Math.sin(x * 2 + Date.now() * 0.001);
                        const cosmic = Math.sin(x + Date.now() * 0.0005);

                        const y = (quantum + atomic + molecular + macro + cosmic) * coupling + cosmic * (1 - coupling);
                        stellaPoints.push({x, y});
                    }
                    data.push({id: 'stella', name: 'Stella-Lorraine', points: stellaPoints});
                }

                if (systemType === 'harmonic') {
                    const harmonicPoints = [];
                    for (let i = 0; i < points; i++) {
                        const x = (i / points) * 2 * Math.PI;
                        const y = Math.sin(x + Date.now() * 0.001);
                        harmonicPoints.push({x, y});
                    }
                    data.push({id: 'harmonic', name: 'Simple Harmonic', points: harmonicPoints});
                }

                if (systemType === 'damped') {
                    const dampedPoints = [];
                    for (let i = 0; i < points; i++) {
                        const x = (i / points) * 2 * Math.PI;
                        const decay = Math.exp(-x * 0.3);
                        const y = decay * Math.sin(x * 2 + Date.now() * 0.001);
                        dampedPoints.push({x, y});
                    }
                    data.push({id: 'damped', name: 'Damped Harmonic', points: dampedPoints});
                }

                if (systemType === 'coupled') {
                    const coupledPoints = [];
                    for (let i = 0; i < points; i++) {
                        const x = (i / points) * 2 * Math.PI;
                        const y1 = Math.sin(x + Date.now() * 0.001);
                        const y2 = 0.5 * Math.sin(x * 1.1 + Date.now() * 0.0012);
                        coupledPoints.push({x, y: y1 + y2});
                    }
                    data.push({id: 'coupled', name: 'Coupled Oscillators', points: coupledPoints});
                }

                return data;
            }

            updateOscillationLegend(data) {
                const { svg } = this.oscillationElements;

                svg.selectAll(".legend").remove();

                const legend = svg.append("g")
                    .attr("class", "legend")
                    .attr("transform", "translate(10, 10)");

                const legendItems = legend.selectAll(".legend-item")
                    .data(data)
                    .enter().append("g")
                    .attr("class", "legend-item")
                    .attr("transform", (d, i) => `translate(0, ${i * 20})`);

                legendItems.append("line")
                    .attr("x1", 0)
                    .attr("x2", 20)
                    .attr("y1", 10)
                    .attr("y2", 10)
                    .attr("class", d => d.id === 'stella' ? 'stella-lorraine' : 'comparison-system')
                    .style("stroke-width", d => d.id === 'stella' ? 3 : 2);

                legendItems.append("text")
                    .attr("x", 25)
                    .attr("y", 10)
                    .attr("dy", "0.35em")
                    .text(d => d.name);
            }

            initPerformanceViz() {
                const svg = d3.select("#performance-viz");
                const margin = {top: 20, right: 30, bottom: 60, left: 80};
                const width = 550 - margin.left - margin.right;
                const height = 400 - margin.top - margin.bottom;

                svg.selectAll("*").remove();

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                this.performanceElements = {
                    svg: g,
                    width: width,
                    height: height,
                    margin: margin
                };

                this.updatePerformanceViz();
            }

            updatePerformanceViz() {
                const metric = d3.select("#performance-metric").property("value");
                const scale = d3.select("#performance-scale").property("value");

                const { svg, width, height } = this.performanceElements;

                svg.selectAll("*").remove();

                // Scales
                const xScale = d3.scaleBand()
                    .domain(this.performanceData.map(d => d.name))
                    .range([0, width])
                    .padding(0.2);

                let yScale;
                const values = this.performanceData.map(d => d[metric]);

                if (scale === 'log') {
                    yScale = d3.scaleLog()
                        .domain([Math.min(...values.filter(v => v > 0)), Math.max(...values)])
                        .range([height, 0]);
                } else {
                    yScale = d3.scaleLinear()
                        .domain([0, Math.max(...values)])
                        .range([height, 0]);
                }

                // Color scale
                const colorScale = d3.scaleOrdinal()
                    .domain(this.performanceData.map(d => d.name))
                    .range(['#3498db', '#2ecc71', '#f39c12', '#e74c3c', '#ff4757']);

                // Bars
                svg.selectAll(".performance-bar")
                    .data(this.performanceData)
                    .enter().append("rect")
                    .attr("class", "performance-bar")
                    .attr("x", d => xScale(d.name))
                    .attr("width", xScale.bandwidth())
                    .attr("y", height)
                    .attr("height", 0)
                    .attr("fill", d => d.name === 'Stella-Lorraine' ? '#ff4757' : colorScale(d.name))
                    .on("mouseover", (event, d) => {
                        this.showTooltip(event, `${d.name}<br/>${metric}: ${d[metric]}`);
                    })
                    .on("mouseout", () => {
                        this.hideTooltip();
                    })
                    .transition()
                    .duration(1000)
                    .attr("y", d => yScale(d[metric]))
                    .attr("height", d => height - yScale(d[metric]));

                // Axes
                svg.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale))
                    .selectAll("text")
                    .style("text-anchor", "end")
                    .attr("dx", "-.8em")
                    .attr("dy", ".15em")
                    .attr("transform", "rotate(-45)");

                svg.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(yScale).tickFormat(d3.format(".2s")));

                // Axis labels
                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 0 - 60)
                    .attr("x", 0 - (height / 2))
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .attr("fill", "white")
                    .text(metric.charAt(0).toUpperCase() + metric.slice(1));
            }

            initConsciousnessViz() {
                const svg = d3.select("#consciousness-viz");
                const margin = {top: 20, right: 30, bottom: 40, left: 50};
                const width = 550 - margin.left - margin.right;
                const height = 400 - margin.top - margin.bottom;

                svg.selectAll("*").remove();

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                this.consciousnessElements = {
                    svg: g,
                    width: width,
                    height: height
                };

                this.updateConsciousnessViz();
            }

            updateConsciousnessViz() {
                const populationSize = +d3.select("#population-size").property("value");
                const freeWillFactor = +d3.select("#free-will-factor").property("value");
                const nordicParadox = d3.select("#nordic-paradox").property("checked");

                // Update display values
                d3.select("#population-display").text(populationSize);
                d3.select("#freewill-display").text(freeWillFactor.toFixed(2));

                const { svg, width, height } = this.consciousnessElements;

                svg.selectAll("*").remove();

                // Generate consciousness data
                const consciousnessData = this.generateConsciousnessData(populationSize, freeWillFactor, nordicParadox);

                // Scales
                const xScale = d3.scaleLinear()
                    .domain(d3.extent(consciousnessData, d => d.constraint))
                    .range([0, width]);

                const yScale = d3.scaleLinear()
                    .domain(d3.extent(consciousnessData, d => d.freedom))
                    .range([height, 0]);

                const colorScale = d3.scaleSequential(d3.interpolateViridis)
                    .domain(d3.extent(consciousnessData, d => d.happiness));

                // Points
                svg.selectAll(".consciousness-node")
                    .data(consciousnessData)
                    .enter().append("circle")
                    .attr("class", "consciousness-node")
                    .attr("cx", d => xScale(d.constraint))
                    .attr("cy", d => yScale(d.freedom))
                    .attr("r", 0)
                    .attr("fill", d => colorScale(d.happiness))
                    .attr("opacity", 0.7)
                    .on("mouseover", (event, d) => {
                        this.showTooltip(event,
                            `Constraint: ${d.constraint.toFixed(2)}<br/>
                             Freedom: ${d.freedom.toFixed(2)}<br/>
                             Happiness: ${d.happiness.toFixed(2)}<br/>
                             Targeting Acc: ${d.targetingAccuracy.toFixed(2)}`);
                    })
                    .on("mouseout", () => {
                        this.hideTooltip();
                    })
                    .transition()
                    .duration(1000)
                    .attr("r", 3);

                // Axes
                svg.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale));

                svg.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(yScale));

                // Axis labels
                svg.append("text")
                    .attr("transform", `translate(${width/2}, ${height + 35})`)
                    .style("text-anchor", "middle")
                    .attr("fill", "white")
                    .text("Systematic Constraint");

                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 0 - 40)
                    .attr("x", 0 - (height / 2))
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .attr("fill", "white")
                    .text("Subjective Freedom");

                // Add trend line if Nordic paradox is enabled
                if (nordicParadox) {
                    this.addNordicParadoxTrendLine(svg, xScale, yScale, consciousnessData);
                }
            }

            generateConsciousnessData(populationSize, freeWillFactor, nordicParadox) {
                const data = [];

                for (let i = 0; i < Math.min(populationSize, 1000); i++) { // Limit for performance
                    const constraint = Math.random();
                    let freedom;

                    if (nordicParadox) {
                        // Nordic paradox: higher constraint = higher subjective freedom
                        freedom = constraint + Math.random() * 0.3 - 0.15;
                    } else {
                        freedom = Math.random();
                    }

                    freedom = Math.max(0, Math.min(1, freedom));

                    const happiness = nordicParadox ?
                        constraint * freedom + Math.random() * 0.2 :
                        Math.random();

                    const targetingAccuracy = (freeWillFactor * (1 - constraint) + freedom * 0.8) / 2;

                    data.push({
                        constraint: constraint,
                        freedom: freedom,
                        happiness: happiness,
                        targetingAccuracy: targetingAccuracy
                    });
                }

                return data;
            }

            addNordicParadoxTrendLine(svg, xScale, yScale, data) {
                // Calculate trend line
                const line = d3.line()
                    .x(d => xScale(d.constraint))
                    .y(d => yScale(d.freedom))
                    .curve(d3.curveCardinal);

                // Sort data by constraint for trend line
                const sortedData = data.slice().sort((a, b) => a.constraint - b.constraint);
                const trendData = [];

                // Create binned averages for smooth trend line
                const bins = 10;
                for (let i = 0; i < bins; i++) {
                    const start = Math.floor(i * sortedData.length / bins);
                    const end = Math.floor((i + 1) * sortedData.length / bins);
                    const binData = sortedData.slice(start, end);

                    if (binData.length > 0) {
                        const avgConstraint = d3.mean(binData, d => d.constraint);
                        const avgFreedom = d3.mean(binData, d => d.freedom);
                        trendData.push({constraint: avgConstraint, freedom: avgFreedom});
                    }
                }

                svg.append("path")
                    .datum(trendData)
                    .attr("fill", "none")
                    .attr("stroke", "#ffd700")
                    .attr("stroke-width", 3)
                    .attr("stroke-dasharray", "5,5")
                    .attr("opacity", 0.8)
                    .attr("d", line);

                // Add trend line label
                svg.append("text")
                    .attr("x", xScale(0.7))
                    .attr("y", yScale(0.8))
                    .attr("fill", "#ffd700")
                    .attr("font-weight", "bold")
                    .text("Nordic Paradox Trend");
            }

            initMemorialViz() {
                const svg = d3.select("#memorial-viz");
                const margin = {top: 20, right: 30, bottom: 40, left: 50};
                const width = 550 - margin.left - margin.right;
                const height = 400 - margin.top - margin.bottom;

                svg.selectAll("*").remove();

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                this.memorialElements = {
                    svg: g,
                    width: width,
                    height: height
                };

                this.updateMemorialViz();
            }

            updateMemorialViz() {
                const comparison = d3.select("#memorial-comparison").property("value");
                const showTraditional = d3.select("#show-traditional").property("checked");

                const { svg, width, height } = this.memorialElements;

                svg.selectAll("*").remove();

                let data = this.memorialData.slice();
                if (!showTraditional) {
                    data = data.filter(d => d.name !== 'Traditional');
                }

                // Create radar chart for memorial comparison
                this.createRadarChart(svg, data, comparison, width, height);
            }

            createRadarChart(svg, data, metric, width, height) {
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) / 2 - 50;

                const metrics = ['effectiveness', 'cost', 'longevity', 'accessibility'];
                const angleStep = (2 * Math.PI) / metrics.length;

                // Draw radar grid
                const levels = 5;
                for (let i = 1; i <= levels; i++) {
                    const levelRadius = (radius * i) / levels;

                    svg.append("circle")
                        .attr("cx", centerX)
                        .attr("cy", centerY)
                        .attr("r", levelRadius)
                        .attr("fill", "none")
                        .attr("stroke", "rgba(255,255,255,0.3)")
                        .attr("stroke-width", 1);
                }

                // Draw radar axes
                metrics.forEach((metric, i) => {
                    const angle = i * angleStep - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;

                    svg.append("line")
                        .attr("x1", centerX)
                        .attr("y1", centerY)
                        .attr("x2", x)
                        .attr("y2", y)
                        .attr("stroke", "rgba(255,255,255,0.5)")
                        .attr("stroke-width", 1);

                    // Add labels
                    const labelX = centerX + Math.cos(angle) * (radius + 20);
                    const labelY = centerY + Math.sin(angle) * (radius + 20);

                    svg.append("text")
                        .attr("x", labelX)
                        .attr("y", labelY)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .attr("fill", "white")
                        .attr("font-size", "12px")
                        .text(metric.charAt(0).toUpperCase() + metric.slice(1));
                });

                // Draw data polygons
                const colors = ['#3498db', '#e74c3c', '#ff4757'];

                data.forEach((system, systemIndex) => {
                    const points = metrics.map((metric, i) => {
                        const angle = i * angleStep - Math.PI / 2;
                        const value = metric === 'cost' ? 1 - (system[metric] / 1000) : system[metric]; // Invert cost
                        const distance = (value * radius);
                        const x = centerX + Math.cos(angle) * distance;
                        const y = centerY + Math.sin(angle) * distance;
                        return [x, y];
                    });

                    // Close the polygon
                    points.push(points[0]);

                    const line = d3.line();

                    svg.append("path")
                        .datum(points)
                        .attr("d", line)
                        .attr("fill", colors[systemIndex])
                        .attr("fill-opacity", 0.2)
                        .attr("stroke", colors[systemIndex])
                        .attr("stroke-width", system.name === 'Stella-Lorraine' ? 3 : 2)
                        .attr("class", system.name === 'Stella-Lorraine' ? 'pulsing' : '');

                    // Add dots at data points
                    points.slice(0, -1).forEach((point, i) => {
                        svg.append("circle")
                            .attr("cx", point[0])
                            .attr("cy", point[1])
                            .attr("r", 4)
                            .attr("fill", colors[systemIndex])
                            .on("mouseover", (event) => {
                                const metricName = metrics[i];
                                const value = system[metricName];
                                this.showTooltip(event, `${system.name}<br/>${metricName}: ${value}`);
                            })
                            .on("mouseout", () => {
                                this.hideTooltip();
                            });
                    });
                });

                // Add legend
                const legend = svg.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(20, 20)`);

                data.forEach((system, i) => {
                    const legendItem = legend.append("g")
                        .attr("transform", `translate(0, ${i * 20})`);

                    legendItem.append("circle")
                        .attr("r", 5)
                        .attr("fill", colors[i]);

                    legendItem.append("text")
                        .attr("x", 15)
                        .attr("dy", "0.35em")
                        .attr("fill", "white")
                        .attr("font-size", "12px")
                        .text(system.name);
                });
            }

            initDashboard() {
                const svg = d3.select("#dashboard-viz");
                const margin = {top: 40, right: 40, bottom: 60, left: 80};
                const width = 1200 - margin.left - margin.right;
                const height = 600 - margin.top - margin.bottom;

                svg.selectAll("*").remove();

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                this.dashboardElements = {
                    svg: g,
                    width: width,
                    height: height
                };

                this.updateDashboard();
            }

            updateDashboard() {
                const { svg, width, height } = this.dashboardElements;

                svg.selectAll("*").remove();

                // Create multi-panel dashboard
                const panelWidth = width / 3;
                const panelHeight = height / 2;

                // Panel 1: Real-time metrics
                this.createMetricsPanel(svg, 0, 0, panelWidth, panelHeight);

                // Panel 2: System comparison
                this.createComparisonPanel(svg, panelWidth, 0, panelWidth, panelHeight);

                // Panel 3: Performance trends
                this.createTrendsPanel(svg, panelWidth * 2, 0, panelWidth, panelHeight);

                // Panel 4: Consciousness analysis
                this.createConsciousnessPanel(svg, 0, panelHeight, panelWidth, panelHeight);

                // Panel 5: Memorial effectiveness
                this.createMemorialPanel(svg, panelWidth, panelHeight, panelWidth, panelHeight);

                // Panel 6: Theoretical validation
                this.createValidationPanel(svg, panelWidth * 2, panelHeight, panelWidth, panelHeight);

                // Update displays
                d3.select("#update-display").text(d3.select("#update-rate").property("value") + "ms");
            }

            createMetricsPanel(svg, x, y, width, height) {
                const panel = svg.append("g")
                    .attr("transform", `translate(${x}, ${y})`);

                // Panel background
                panel.append("rect")
                    .attr("width", width - 10)
                    .attr("height", height - 10)
                    .attr("fill", "rgba(255,255,255,0.1)")
                    .attr("stroke", "rgba(255,255,255,0.3)")
                    .attr("rx", 5);

                // Panel title
                panel.append("text")
                    .attr("x", width / 2)
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .attr("class", "metrics-text")
                    .text("Real-time Metrics");

                // Add metrics display
                const metrics = [
                    {label: "Precision", value: "0.1ns", color: "#2ecc71"},
                    {label: "Latency", value: "0.0001ms", color: "#3498db"},
                    {label: "Stability", value: "99.5%", color: "#f39c12"},
                    {label: "Efficiency", value: "99.9%", color: "#e74c3c"}
                ];

                metrics.forEach((metric, i) => {
                    const yPos = 60 + i * 35;

                    panel.append("text")
                        .attr("x", 20)
                        .attr("y", yPos)
                        .attr("fill", "white")
                        .attr("font-size", "14px")
                        .text(metric.label + ":");

                    panel.append("text")
                        .attr("x", width - 30)
                        .attr("y", yPos)
                        .attr("text-anchor", "end")
                        .attr("fill", metric.color)
                        .attr("font-size", "16px")
                        .attr("font-weight", "bold")
                        .text(metric.value);
                });
            }

            createComparisonPanel(svg, x, y, width, height) {
                const panel = svg.append("g")
                    .attr("transform", `translate(${x}, ${y})`);

                panel.append("rect")
                    .attr("width", width - 10)
                    .attr("height", height - 10)
                    .attr("fill", "rgba(255,255,255,0.1)")
                    .attr("stroke", "rgba(255,255,255,0.3)")
                    .attr("rx", 5);

                panel.append("text")
                    .attr("x", width / 2)
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .attr("class", "metrics-text")
                    .text("System Comparison");

                // Mini bar chart
                const barData = [
                    {name: "Traditional", value: 0.3},
                    {name: "Digital", value: 0.6},
                    {name: "Stella-Lorraine", value: 0.95}
                ];

                const barScale = d3.scaleLinear()
                    .domain([0, 1])
                    .range([0, width - 60]);

                barData.forEach((d, i) => {
                    const yPos = 50 + i * 25;

                    panel.append("rect")
                        .attr("x", 20)
                        .attr("y", yPos)
                        .attr("width", 0)
                        .attr("height", 15)
                        .attr("fill", d.name === "Stella-Lorraine" ? "#ff4757" : "#3498db")
                        .transition()
                        .duration(1000)
                        .attr("width", barScale(d.value));

                    panel.append("text")
                        .attr("x", 20)
                        .attr("y", yPos - 5)
                        .attr("fill", "white")
                        .attr("font-size", "12px")
                        .text(d.name);
                });
            }

            createTrendsPanel(svg, x, y, width, height) {
                const panel = svg.append("g")
                    .attr("transform", `translate(${x}, ${y})`);

                panel.append("rect")
                    .attr("width", width - 10)
                    .attr("height", height - 10)
                    .attr("fill", "rgba(255,255,255,0.1)")
                    .attr("stroke", "rgba(255,255,255,0.3)")
                    .attr("rx", 5);

                panel.append("text")
                    .attr("x", width / 2)
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .attr("class", "metrics-text")
                    .text("Performance Trends");

                // Simple trend line
                const trendData = [];
                for (let i = 0; i < 50; i++) {
                    trendData.push({
                        x: i,
                        y: 0.5 + 0.4 * Math.sin(i * 0.2) + Math.random() * 0.1
                    });
                }

                const xScale = d3.scaleLinear()
                    .domain([0, 49])
                    .range([20, width - 30]);

                const yScale = d3.scaleLinear()
                    .domain([0, 1])
                    .range([height - 40, 40]);

                const line = d3.line()
                    .x(d => xScale(d.x))
                    .y(d => yScale(d.y))
                    .curve(d3.curveCardinal);

                panel.append("path")
                    .datum(trendData)
                    .attr("fill", "none")
                    .attr("stroke", "#2ecc71")
                    .attr("stroke-width", 2)
                    .attr("d", line);
            }

            createConsciousnessPanel(svg, x, y, width, height) {
                const panel = svg.append("g")
                    .attr("transform", `translate(${x}, ${y})`);

                panel.append("rect")
                    .attr("width", width - 10)
                    .attr("height", height - 10)
                    .attr("fill", "rgba(255,255,255,0.1)")
                    .attr("stroke", "rgba(255,255,255,0.3)")
                    .attr("rx", 5);

                panel.append("text")
                    .attr("x", width / 2)
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .attr("class", "metrics-text")
                    .text("Consciousness Analysis");

                // Consciousness targeting gauge
                const gaugeRadius = Math.min(width, height - 60) / 4;
                const gaugeCenterX = width / 2;
                const gaugeCenterY = height / 2 + 10;

                // Background arc
                const arc = d3.arc()
                    .innerRadius(gaugeRadius - 20)
                    .outerRadius(gaugeRadius)
                    .startAngle(-Math.PI / 2)
                    .endAngle(Math.PI / 2);

                panel.append("path")
                    .attr("d", arc)
                    .attr("fill", "rgba(255,255,255,0.2)")
                    .attr("transform", `translate(${gaugeCenterX}, ${gaugeCenterY})`);

                // Progress arc (95% accuracy)
                const progressArc = d3.arc()
                    .innerRadius(gaugeRadius - 20)
                    .outerRadius(gaugeRadius)
                    .startAngle(-Math.PI / 2)
                    .endAngle(-Math.PI / 2 + Math.PI * 0.95);

                panel.append("path")
                    .attr("d", progressArc)
                    .attr("fill", "#2ecc71")
                    .attr("transform", `translate(${gaugeCenterX}, ${gaugeCenterY})`);

                panel.append("text")
                    .attr("x", gaugeCenterX)
                    .attr("y", gaugeCenterY + 5)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-size", "18px")
                    .attr("font-weight", "bold")
                    .text("95%");
            }

            createMemorialPanel(svg, x, y, width, height) {
                const panel = svg.append("g")
                    .attr("transform", `translate(${x}, ${y})`);

                panel.append("rect")
                    .attr("width", width - 10)
                    .attr("height", height - 10)
                    .attr("fill", "rgba(255,255,255,0.1)")
                    .attr("stroke", "rgba(255,255,255,0.3)")
                    .attr("rx", 5);

                panel.append("text")
                    .attr("x", width / 2)
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .attr("class", "metrics-text")
                    .text("Memorial Effectiveness");

                // Cost efficiency indicator
                const costSavings = 99; // 99% cost reduction

                panel.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2 - 10)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#2ecc71")
                    .attr("font-size", "36px")
                    .attr("font-weight", "bold")
                    .text(costSavings + "%");

                panel.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2 + 15)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-size", "14px")
                    .text("Cost Reduction");
            }

            createValidationPanel(svg, x, y, width, height) {
                const panel = svg.append("g")
                    .attr("transform", `translate(${x}, ${y})`);

                panel.append("rect")
                    .attr("width", width - 10)
                    .attr("height", height - 10)
                    .attr("fill", "rgba(255,255,255,0.1)")
                    .attr("stroke", "rgba(255,255,255,0.3)")
                    .attr("rx", 5);

                panel.append("text")
                    .attr("x", width / 2)
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .attr("class", "metrics-text")
                    .text("Theoretical Validation");

                const validations = [
                    "Universal Oscillation: ✓",
                    "Nordic Paradox: ✓",
                    "Death Proximity: ✓",
                    "Consciousness Inheritance: ✓"
                ];

                validations.forEach((validation, i) => {
                    panel.append("text")
                        .attr("x", 20)
                        .attr("y", 50 + i * 25)
                        .attr("fill", "#2ecc71")
                        .attr("font-size", "14px")
                        .text(validation);
                });
            }

            setupEventListeners() {
                // Oscillation controls
                d3.select("#oscillation-speed").on("input", () => {
                    this.animationSpeed = +d3.select("#oscillation-speed").property("value");
                });

                d3.select("#coupling-strength").on("input", () => {
                    this.updateOscillationViz();
                });

                d3.select("#oscillation-system").on("change", () => {
                    this.updateOscillationViz();
                });

                // Performance controls
                d3.select("#performance-metric").on("change", () => {
                    this.updatePerformanceViz();
                });

                d3.select("#performance-scale").on("change", () => {
                    this.updatePerformanceViz();
                });

                // Consciousness controls
                d3.select("#population-size").on("input", () => {
                    this.updateConsciousnessViz();
                });

                d3.select("#free-will-factor").on("input", () => {
                    this.updateConsciousnessViz();
                });

                d3.select("#nordic-paradox").on("change", () => {
                    this.updateConsciousnessViz();
                });

                // Memorial controls
                d3.select("#memorial-comparison").on("change", () => {
                    this.updateMemorialViz();
                });

                d3.select("#show-traditional").on("change", () => {
                    this.updateMemorialViz();
                });

                // Dashboard controls
                d3.select("#update-rate").on("input", () => {
                    d3.select("#update-display").text(d3.select("#update-rate").property("value") + "ms");
                    this.setupAutoUpdate();
                });

                d3.select("#auto-update").on("change", () => {
                    this.setupAutoUpdate();
                });
            }

            setupAutoUpdate() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                }

                if (d3.select("#auto-update").property("checked")) {
                    const updateRate = +d3.select("#update-rate").property("value");
                    this.updateInterval = setInterval(() => {
                        this.updateDashboard();
                    }, updateRate);
                }
            }

            startAnimations() {
                const animate = () => {
                    if (this.isAnimating) {
                        this.updateOscillationViz();
                        setTimeout(() => {
                            requestAnimationFrame(animate);
                        }, 1000 / (this.animationSpeed * 10));
                    }
                };
                animate();
            }

            showTooltip(event, content) {
                this.tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);

                this.tooltip.html(content)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            }

            hideTooltip() {
                this.tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            }
        }

        // Initialize visualizations when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new StellaLorraineVisualizations();
        });
    </script>
</body>
</html>
